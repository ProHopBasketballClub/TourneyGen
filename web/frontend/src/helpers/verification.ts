import * as HttpStatus from 'http-status-codes';
import * as env from '../../env';
import ApiRequest from '../api_request/api_request';
import { default_cookie_max_age } from '../constants/cookie';
import { user_route } from '../constants/routes';
const backend_location = (env as any).env.BACKEND_LOCATION;

export function create_cookie(cookie_name, cookie_value, res, cookie_params: object = { maxAge: default_cookie_max_age, httpOnly: true }) {
    // Adds a cookie to the browser with the name and value passed.
    res.cookie(cookie_name, cookie_value, cookie_params);
}

export function destroy_cookie(cookie_name: string, cookies) {
    // Removed the cookie from the browser with the passed name.

    if (!cookies[cookie_name]) {
        return false;
    }

    cookies.set(cookie_name, { expires: Date.now(), maxAge: 0 });
    return true;
}

export function generate_auth_token(id: string, email: string, name: string, random: number) {
    /* Theoretically some security could be added here.
        for now just returning concat of free data.
        Note, methods using this function *should*
        use it in a way disallowing reversabililty (ie checking
        necessary information against this.) That way if real
        security is implemented here it will be useable.
    */
    return id + email + name + random.toString();
}

export function is_logged_in(cookies, success_callback, failure_callback) {
    /* Checks whether the user is logged in or not. This is done by verifying that
        the auth token attached to the browser is identical to the auth token
        generated by the user's object.

        If the user is logged in, then the success_callback function will
        be called with their object from the database.

        If the user is not logged in, then the failure_callback function will
        be called with an object specifying the `reason` that the authentication
        failed.
    */
    if (!cookies.tourneygen_auth || !cookies.tourneygen_srn || !cookies.tourneygen_user ) {
        return failure_callback( { reason: 'Missing cookies have rendered authentication impossible.' } );
    }
    const tourneygen_auth = unescape(cookies.tourneygen_auth);
    const tourneygen_srn = cookies.tourneygen_srn; // No need to unescape as this is a number.
    const tourneygen_user = unescape(cookies.tourneygen_user);

    const params = { displayName: tourneygen_user } as object;
    const request_route = backend_location + user_route;
    const request = new ApiRequest('GET', request_route, { params, body: {} });

    request.send_request( (user_object) => {
        if (!user_object || user_object.status_code === HttpStatus.NOT_FOUND) {
            return failure_callback({ reason: 'User not found.' });
        }

        // Generate and check the auth token with the one stored in browser.
        const auth_token = generate_auth_token(user_object._id, user_object.email, user_object.displayName, tourneygen_srn);
        if (auth_token === tourneygen_auth) {
            return success_callback(user_object); // On success, return the logged-in user's object.
        } else {
            return failure_callback({ reason: 'Generated token did not match stored token.' });
        }
    });
}
