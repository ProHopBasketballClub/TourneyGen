import * as http from 'http';
import * as env from '../../env';
import { default_cookie_max_age } from '../constants/cookie';
import { user_route } from '../constants/routes';
const backend_location = (env as any).env.BACKEND_LOCATION;

export function api_get_request(route: string, callback) {
    /* Sends an HTTP GET request to the passed route, calling
        the callback method with whatever response the backend
        gives.
    */
    let data: string = '';
    let APIResponse;

    http.get(route, (resp) => {

        // A chunk of data has been recieved.
        resp.on('data', (chunk) => {
            data += chunk;
        });

        // The whole response has been received. return the data
        resp.on('end', () => {
            try {
                APIResponse = JSON.parse(data);
            } catch (e) {
                callback(null);
                return;
            }
            callback(APIResponse);
        });
    }).on('error', (err) => {
        callback(null);
    });
}

export function create_cookie(cookie_name, cookie_value, res, cookie_params: object = { maxAge: default_cookie_max_age, httpOnly: true }) {
    // Adds a cookie to the browser with the name and value passed.
    res.cookie(cookie_name, cookie_value, cookie_params);
}

export function destroy_cookie(cookie_name: string, cookies) {
    // Removed the cookie from the browser with the passed name.

    if (!cookies[cookie_name]) {
        return false;
    }

    cookies.set(cookie_name, { expires: Date.now(), maxAge: 0 });
    return true;
}

export function generate_auth_token(id: string, email: string, name: string, random: number) {
    /* Theoretically some security could be added here.
        for now just returning concat of free data.
        Note, methods using this function *should*
        use it in a way disallowing reversabililty (ie checking
        necessary information against this.) That way if real
        security is implemented here it will be useable.
    */
    return id + email + name + random.toString();
}

export function generate_get_route(route, args) {
    let get_route = route + '?';
    for (const [key, value] of Object.entries(args)) {
        get_route += key.toString() + '=' + value.toString() + '&';
    }

    // Don't return the last &.
    return get_route.slice(0, -1);
}

export function is_logged_in(cookies, success_callback, failure_callback) {
    /* Checks whether the user is logged in or not. This is done by verifying that
        the auth token attached to the browser is identical to the auth token
        generated by the user's object.

        If the user is logged in, then the success_callback function will
        be called with their object from the database.

        If the user is not logged in, then the failure_callback function will
        be called with an object specifying the `reason` that the authentication
        failed.
    */
    if (!cookies.tourneygen_auth || !cookies.tourneygen_srn || !cookies.tourneygen_user ) {
        failure_callback( { reason: 'Missing cookies have rendered authentication impossible.' } );
        return;
    }
    const tourneygen_auth = unescape(cookies.tourneygen_auth);
    const tourneygen_srn = cookies.tourneygen_srn; // No need to unescape as this is a number.
    const tourneygen_user = unescape(cookies.tourneygen_user);

    const route = backend_location + generate_get_route(user_route, { displayName: tourneygen_user });

    api_get_request(route, (user_object) => {
        if (!user_object) {
            failure_callback({ reason: 'User not found.' });
            return;
        }

        // Generate and check the auth token with the one stored in browser.
        const auth_token = generate_auth_token(user_object._id, user_object.email, user_object.displayName, tourneygen_srn);
        if (auth_token === tourneygen_auth) {
            success_callback(user_object); // On success, return the logged-in user's object.
        } else {
            failure_callback({ reason: 'Generated token did not match stored token.' });
        }
    });
}
